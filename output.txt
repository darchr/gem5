commit 8efc94e9c0c699ef68da1c2563be7b52bb89a8ee
Author: Zhantong Qiu <ztqiu@ucdavis.edu>
Date:   Mon Aug 1 16:07:05 2022 -0700

    stdlib: take and create exit event for simpoint
    
    Change-Id: I26b447801e22a51a182483faf878b580e53f5799

diff --git a/src/cpu/BaseCPU.py b/src/cpu/BaseCPU.py
index 5a627037d5..c9c307d6b0 100644
--- a/src/cpu/BaseCPU.py
+++ b/src/cpu/BaseCPU.py
@@ -70,6 +70,7 @@ class BaseCPU(ClockedObject):
         PyBindMethod("totalInsts"),
         PyBindMethod("scheduleInstStop"),
         PyBindMethod("getCurrentInstCount"),
+        PyBindMethod("scheduleSimpoint")
     ]
 
     @classmethod
@@ -131,8 +132,10 @@ class BaseCPU(ClockedObject):
         "terminate when any thread reaches this inst count")
     simpoint_start_insts = VectorParam.Counter([],
         "starting instruction counts of simpoints")
-    simpoint_end_insts = VectorParam.Counter([],
-        "ending instruction counts of simpoints")
+    simpoint_interval = Param.Counter(0,
+        "interval length of simpoints")
+    schedule_at_init = Param.Bool(True,"if the simpoint should be scheduled"
+        "at the init stage")
     progress_interval = Param.Frequency('0Hz',
         "frequency to print out the progress message")
 
diff --git a/src/cpu/base.cc b/src/cpu/base.cc
index aab629c166..4bd4d3fe71 100644
--- a/src/cpu/base.cc
+++ b/src/cpu/base.cc
@@ -284,13 +284,10 @@ BaseCPU::init()
     // Typically, there are more than one action points.
     // Simulation.py is responsible to take the necessary actions upon
     // exitting the simulation loop.
-    if (!params().simpoint_start_insts.empty()) {
-        const char *cause1 = "simpoint starting point found";
-        const char *cause2 = "simpoint ending point found";
-        for (size_t i = 0; i < params().simpoint_start_insts.size(); ++i) {
-            scheduleInstStop(0, params().simpoint_start_insts[i], cause1);
-            scheduleInstStop(0, params().simpoint_end_insts[i], cause2);
-        }
+    if (!params().simpoint_start_insts.empty() && params().schedule_at_init) {
+
+        scheduleSimpoint(0);
+
     }
 
     if (params().max_insts_all_threads != 0) {
@@ -730,6 +727,28 @@ BaseCPU::traceFunctionsInternal(Addr pc)
     }
 }
 
+void
+BaseCPU::scheduleSimpoint(Counter end_point)
+{
+    const char *cause1 = "simpoint starting point found";
+    const char *cause2 = "simpoint ending point found";
+    if (end_point == 0)
+    {
+        for (size_t i = 0; i < params().simpoint_start_insts.size(); ++i) {
+            scheduleInstStop(0, params().simpoint_start_insts[i], cause1);
+            scheduleInstStop(
+                0,
+                ((params().simpoint_start_insts[i] + \
+                params().simpoint_interval) -1) ,
+                cause2
+            );
+        }
+    }
+    else {
+        scheduleInstStop(0, end_point-1, cause2);
+    }
+
+}
 
 BaseCPU::GlobalStats::GlobalStats(statistics::Group *parent)
     : statistics::Group(parent),
diff --git a/src/cpu/base.hh b/src/cpu/base.hh
index afee2365e9..5d2445c3e9 100644
--- a/src/cpu/base.hh
+++ b/src/cpu/base.hh
@@ -178,6 +178,7 @@ class BaseCPU : public ClockedObject
      */
     virtual Port &getDataPort() = 0;
 
+    void scheduleSimpoint(Counter  end_point);
     /**
      * Purely virtual method that returns a reference to the instruction
      * port. All subclasses must implement this method.
diff --git a/src/python/gem5/components/boards/se_binary_workload.py b/src/python/gem5/components/boards/se_binary_workload.py
index 8e406dc567..d3b7b4856d 100644
--- a/src/python/gem5/components/boards/se_binary_workload.py
+++ b/src/python/gem5/components/boards/se_binary_workload.py
@@ -86,12 +86,12 @@ class SEBinaryWorkload:
         # simpoint part start
         if simpoint_starts is not None:
           simpoint_begin_inst = []
-          simpoint_end_inst = []
           for point in simpoint_starts:
             simpoint_begin_inst.append(point * simpoint_interval)
-            simpoint_end_inst.append((point+1)*simpoint_interval - 1)
-          self.get_processor().get_cores()[0].set_simpoint(simpoint_begin_inst,
-            simpoint_end_inst)
+          self.get_processor().get_cores()[0].set_simpoint(
+              simpoint_begin_inst,
+              simpoint_interval
+            )
         # simpoint part end
 
         # Set whether to exit on work items for the se_workload
diff --git a/src/python/gem5/components/processors/abstract_core.py b/src/python/gem5/components/processors/abstract_core.py
index 14293fbacf..784c9bdbd6 100644
--- a/src/python/gem5/components/processors/abstract_core.py
+++ b/src/python/gem5/components/processors/abstract_core.py
@@ -90,7 +90,8 @@ class AbstractCore(SubSystem):
     def set_simpoint(
         self, 
         simpoint_starts: List[int], 
-        simpoint_ends: List[int]
+        simpoint_interval: int,
+        schedule_at_init: bool = True
     ) -> None:
         raise NotImplementedError
 
@@ -118,6 +119,19 @@ class AbstractCore(SubSystem):
         """
         raise NotImplementedError
 
+    @abstractmethod
+    def tesing(self) -> None:
+
+        raise NotImplementedError
+
+    @abstractmethod
+    def fs_set_simpoint(
+        self,
+        end_point: int = 0
+    ) -> None:
+        raise NotImplementedError
+
+
     @classmethod
     def cpu_simobject_factory(cls, cpu_type: CPUTypes, isa: ISA, core_id: int):
         """
diff --git a/src/python/gem5/components/processors/simple_core.py b/src/python/gem5/components/processors/simple_core.py
index 8c9f689a67..2d2f29ae8e 100644
--- a/src/python/gem5/components/processors/simple_core.py
+++ b/src/python/gem5/components/processors/simple_core.py
@@ -100,10 +100,12 @@ class SimpleCore(AbstractCore):
     def set_simpoint(
         self, 
         simpoint_starts: List[int], 
-        simpoint_ends: List[int]
+        simpoint_interval: int,
+        schedule_at_init: bool = True
     ) -> None:
         self.core.simpoint_start_insts = simpoint_starts
-        self.core.simpoint_end_insts = simpoint_ends
+        self.core.simpoint_interval = simpoint_interval
+        self.core.schedule_at_init = schedule_at_init
 
     @overrides(AbstractCore)
     def set_switched_out(self, value: bool) -> None:
@@ -129,3 +131,14 @@ class SimpleCore(AbstractCore):
     @overrides(AbstractCore)
     def get_mmu(self) -> BaseMMU:
         return self.core.mmu
+
+    @overrides(AbstractCore)
+    def tesing(self) -> None:
+        self.core.testing()
+
+    @overrides(AbstractCore)
+    def fs_set_simpoint(
+        self,
+        end_point: int = 0
+    ) -> None:
+        self.core.scheduleSimpoint(end_point)
diff --git a/src/python/gem5/simulate/exit_event.py b/src/python/gem5/simulate/exit_event.py
index 671e7e44e2..09c19c6419 100644
--- a/src/python/gem5/simulate/exit_event.py
+++ b/src/python/gem5/simulate/exit_event.py
@@ -46,8 +46,8 @@ class ExitEvent(Enum):
     USER_INTERRUPT = ( # An exit due to a user interrupt (e.g., cntr + c)
         "user interupt"
     )
-    SIMPOINT_BEGIN = "simpoint begin"
-    SIMPOINT_END = "simpoint end"
+    SIMPOINT_BEGIN = "simpoint begins"
+    SIMPOINT_END = "simpoint ends"
 
     @classmethod
     def translate_exit_status(cls, exit_string: str) -> "ExitEvent":
diff --git a/src/python/gem5/simulate/exit_event_generators.py b/src/python/gem5/simulate/exit_event_generators.py
index d9f75adb74..daef925c35 100644
--- a/src/python/gem5/simulate/exit_event_generators.py
+++ b/src/python/gem5/simulate/exit_event_generators.py
@@ -99,23 +99,6 @@ def default_workend_generator():
         yield False
 
 
-def default_simpoint_found(counter: int, take_checkpoint: bool):
+def default_simpoint_generator():
     while True:
-        print("hello, this is simpoint found")
-        if take_checkpoint:
-            if not os.path.exists("testing_simpoint_checkpoint"):
-                os.mkdir("testing_simpoint_checkpoint")
-            m5.checkpoint(joinpath("testing_simpoint_checkpoint",f"cpt.simpoint_checkpoint{counter}"))
-            counter += 1
-        else:
-            m5.stats.dump()
-            m5.stats.reset()
         yield False
-
-
-def default_simpoint_end():
-    while True:
-        print("bye, this is simpoint end")
-        m5.stats.dump()
-        m5.stats.reset()
-        yield False
\ No newline at end of file
diff --git a/src/python/gem5/simulate/simulator.py b/src/python/gem5/simulate/simulator.py
index 74a63c7aa0..551e3d38ad 100644
--- a/src/python/gem5/simulate/simulator.py
+++ b/src/python/gem5/simulate/simulator.py
@@ -40,8 +40,7 @@ from .exit_event_generators import (
     default_switch_generator,
     default_workbegin_generator,
     default_workend_generator,
-    default_simpoint_found,
-    default_simpoint_end,
+    default_simpoint_generator,
 )
 from .exit_event import ExitEvent
 from ..components.boards.abstract_board import AbstractBoard
@@ -80,7 +79,6 @@ class Simulator:
         ] = None,
         expected_execution_order: Optional[List[ExitEvent]] = None,
         checkpoint_path: Optional[Path] = None,
-        simpoint_take_checkpoint: Optional[bool]=False
     ) -> None:
         """
         :param board: The board to be simulated.
@@ -158,8 +156,6 @@ class Simulator:
 
         # We specify a dictionary here outlining the default behavior for each
         # exit event. Each exit event is mapped to a generator.
-        self._simpoint_checkpoints_counter = 0
-        self._take_checkpoint = simpoint_take_checkpoint
         self._default_on_exit_dict = {
             ExitEvent.EXIT: default_exit_generator(),
             # TODO: Something else should be done here for CHECKPOINT
@@ -172,11 +168,8 @@ class Simulator:
             ExitEvent.WORKEND: default_workend_generator(),
             ExitEvent.USER_INTERRUPT: default_exit_generator(),
             ExitEvent.MAX_TICK: default_exit_generator(),
-            ExitEvent.SIMPOINT_BEGIN: default_simpoint_found(
-                counter= self._simpoint_checkpoints_counter,
-                take_checkpoint= self._take_checkpoint
-            ),
-            ExitEvent.SIMPOINT_END: default_simpoint_end(),
+            ExitEvent.SIMPOINT_BEGIN: default_simpoint_generator(),
+            ExitEvent.SIMPOINT_END: default_simpoint_generator(),
         }
 
         if on_exit_event:
