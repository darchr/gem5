/*
 * Copyright (c) 2020 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met: redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer;
 * redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution;
 * neither the name of the copyright holders nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef __ACCL_GRAPH_SEGA_WORK_DIRECTORY_HH__
#define __ACCL_GRAPH_SEGA_WORK_DIRECTORY_HH__

#include "base/addr_range.hh"
#include "base/types.hh"

namespace gem5
{

class WorkDirectory
{
  public:
    virtual int activate(Addr atom_addr) = 0;
    virtual int deactivate(Addr atom_addr) = 0;
    virtual Addr getNextWork() = 0;

    virtual int workCount() = 0;
    bool empty() { return workCount() == 0; }

    virtual void setLastAtomAddr(Addr atom_addr) = 0;
};

class PopCountDirectory: public WorkDirectory
{
  private:
    AddrRange memoryRange;

    int numAtomsPerBlock;
    int memoryAtomSize;
    int blockSize;

    uint32_t _workCount;

    int numCounters;
    int lastCounterIndex;
    uint32_t* popCount;

    uint32_t currentIndex;
    uint32_t currentCounter;

    int getIndexFromAtomAddr(Addr atom_addr)
    {
        assert((atom_addr % memoryAtomSize) == 0);
        Addr trimmed_addr = memoryRange.removeIntlvBits(atom_addr);
        int index = (int) (trimmed_addr / blockSize);
        return index;
    }

    Addr getAtomAddrFromIndex(int block_index, int atom_index)
    {
        Addr block_addr = block_index * blockSize;
        Addr trimmed_addr = block_addr + atom_index * memoryAtomSize;
        return memoryRange.addIntlvBits(trimmed_addr);
    }

  public:
    PopCountDirectory(AddrRange mem_range, int atoms_per_block, int atom_size):
        WorkDirectory(),
        memoryRange(mem_range), numAtomsPerBlock(atoms_per_block),
        memoryAtomSize(atom_size), _workCount(0),
        currentIndex(0), currentCounter(0)
    {
        blockSize = numAtomsPerBlock * memoryAtomSize;
        int numCounters = (int) (memoryRange.size() / blockSize);
        lastCounterIndex = numCounters - 1;
        popCount = new uint32_t [numCounters];
        for (int index = 0; index < numCounters; index++) {
            popCount[index] = 0;
        }
    }

    // CAUTION: This should only be called when the work
    // directory **is not** tracking the the atom with atom_addr
    virtual int activate(Addr atom_addr)
    {
        int index = getIndexFromAtomAddr(atom_addr);
        uint32_t prev_count = popCount[index];
        popCount[index]++;
        _workCount++;
        assert(popCount[index] > prev_count);
        assert(popCount[index] <= numAtomsPerBlock);
        return popCount[index];
    }

    // CAUTION: This should only be called when the work
    // directory **is** tracking the the atom with atom_addr
    virtual int deactivate(Addr atom_addr)
    {
        int index = getIndexFromAtomAddr(atom_addr);
        uint32_t prev_count = popCount[index];
        popCount[index]--;
        _workCount--;
        assert(popCount[index] < prev_count);
        assert(popCount[index] <= numAtomsPerBlock);
        return popCount[index];
    }

    virtual int workCount() { return _workCount; }

    void setLastAtomAddr(Addr atom_addr)
    {
        lastCounterIndex = getIndexFromAtomAddr(atom_addr);
    }

    // CAUTION: If this function returns an addr that
    // is in the cache, that addr should be ignored.
    // CAUTION: The receiver should track the last n
    // addresses that this WorkDirectory has generated.
    // where n is equal to the size of the entry holding
    // reads generated by this WorkDirectory. In case
    // the WorkDirectory generates a repeated address
    // it should be ignored.
    // FIXME: This should return garbage if it can't find anything.
    // virtual Addr getNextWork()
    // {
    //     if ((currentCounter == numAtomsPerBlock) ||
    //         (popCount[currentIndex] == 0)) {
    //         int prev_index = currentIndex;
    //         while (true) {
    //             currentIndex++;
    //             // NOTE: this is an optimization.
    //             // lastCounterIndex tracks the last blockOfAtom that
    //             // has vertices. By default it is set to numCounters - 1.
    //             // However, it might not be necessary to track all the
    //             // numCounters counters. e.g. If this WorkDirectory is tracking
    //             // a 512 MiB memory with atom size of 32 B and 256 atoms
    //             // per block. Then it needs 64 Ki counters of 8 bit wide.
    //             // However, if we need 8 Mi atoms to store all our vertices,
    //             // the second half of the counters would not be used at all
    //             // (512 MiB hold 16 Mi atoms and we're only using half).
    //             if (currentIndex > lastCounterIndex) {
    //                 currentIndex = 0;
    //             }
    //             if (prev_index == currentIndex) {
    //                 // NOTE: If we have reached the same index as before,
    //                 // we need to decrement the currentCounter to generate
    //                 // a repeatative address. This way the receiver can detect
    //                 // the uselessness of the generated address and ignore it
    //                 currentCounter--;
    //                 break;
    //             }
    //             if (popCount[currentIndex] > 0) {
    //                 currentCounter = 0;
    //                 break;
    //             }
    //         }
    //     }
    //     Addr ret_addr = getAtomAddrFromIndex(currentIndex, currentCounter);
    //     currentCounter++;

    //     return ret_addr;
    // }

    virtual Addr getNextWork()
    {
        if ((currentCounter == numAtomsPerBlock) ||
            (popCount[currentIndex] == 0)) {
            int other_count = _workCount - popCount[currentIndex];
            if (other_count == 0) {
                currentCounter = 0;
            } else {
                int prev_index = currentIndex;
                while (true) {
                    currentIndex++;
                    if (currentIndex > lastCounterIndex) {
                        currentIndex = 0;
                    }
                    if (currentIndex == prev_index) {
                        break;
                    }
                    if (popCount[currentIndex] > 0) {
                        break;
                    }
                }
                currentCounter = 0;
            }
        }
        Addr ret_addr = getAtomAddrFromIndex(currentIndex, currentCounter);
        currentCounter++;
        return ret_addr;
    }
};

} // namespace gem5

#endif // __ACCL_GRAPH_SEGA_WORK_DIRECTORY_HH__
