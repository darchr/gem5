

from m5.util import *
from pathlib import Path
from typing import List, Tuple


class Simpoint:
    """
    This Simpoint class is used to manage the information needed for simpoint
    in workload

    """

    def __init__(
        self,
        simpoint_interval = None,
        simpoint_file_path: Path = None,
        weight_file_path: Path = None,
        simpoint_list: List[int] = None,
        weight_list: List[int] = None,
        # bbv_file_path: Path = None, will take in bbv and generate simpoints
        # with it in the future
    ) -> None:
        """
        :param simpoint_interval: the length of each simpoint interval
        :param simpoint_file_path: the path to the simpoint result file
        generated by Simpoint3.2 or gem5
        :param weight_file_path: the path to the weight result file generated
        by Simpoint3.2 or gem5

        :param simpoint_list: a list of simpoint starting instructions (sorted)
        :param weight_list: a list of weights (sorted)

        """

        if simpoint_interval is None:
            fatal("not passing in interval length")

        self._simpoint_interval = simpoint_interval

        if simpoint_file_path is None or weight_file_path is None:
            if simpoint_list is None or weight_list is None:
                # raise error
                fatal("not passing in enough information")
            else:
                self._simpoint_start_insts = \
                    list(inst * simpoint_interval for inst in simpoint_list)
                self._weight_list = weight_list
                # assume the list is sorted
        else:
            # if passing in file paths then it calls the function to generate
            # simpoint_start_insts and weight list from the files
            self._simpoint_start_insts, self._weight_list  = \
                self.get_weights_and_simpoints_from_file(
                    simpoint_file_path,
                    weight_file_path
                    )

    def get_weights_and_simpoints_from_file(
        self,
        simpoint_path:Path,
        weight_path:Path,
        )-> Tuple[List[int],List[int]]:
        simpoint_file = open(simpoint_path)
        weight_file = open(weight_path)
        simpoint = []
        while True:
            line = simpoint_file.readline()
            if not line:
                break
            interval = int(line.split(" ",1)[0])
            # use split instead of re.match because it assumes that users are
            # passing in correct file format and it's more costly to use regex
            # function
            line = weight_file.readline()
            if not line:
                fatal("not engough weights")
            weight = float(line.split(" ",1)[0])
            simpoint.append((interval,weight))
        simpoint.sort(key=lambda obj: obj[0])
        # use simpoint to sort
        simpoint_start_insts = []
        weight_list = []
        for obj in simpoint:
            simpoint_start_insts.append(obj[0]*self._simpoint_interval)
            weight_list.append(obj[1])
        return simpoint_start_insts, weight_list

    def get_simpoint_start_insts(self)->List[int]:
        return self._simpoint_start_insts

    def get_weight_list(self)->List[float]:
        return self._weight_list

    def get_simpoint_interval(self)->int:
        return self._simpoint_interval


